// Expected output
//
// "ONCHAIN_VOLUME_INSERT_TEST: create volume map to store in the registry"
// Unforgeable(0xd3f4cbdcc634e7d6f8edb05689395fef7e190f68fe3a2712e2a9bbe21eb6dd10)
// "ONCHAIN_VOLUME_INSERT_TEST: adding volume map to the registry and getting back a new identifier"
// `rho:id:pnrunpy1yntnsi63hm9pmbg8m1h1h9spyn7zrbh1mcf6pcsdunxcci`
// "ONCHAIN_VOLUME_INSERT_TEST: got an identifier for volume from the registry"
// "ONCHAIN_VOLUME_LOOKUP_TEST: looking up volume map in the registry using identifier"
// "ONCHAIN_VOLUME_LOOKUP_TEST: got volume map from the registry using identifier"
// Unforgeable(0xd3f4cbdcc634e7d6f8edb05689395fef7e190f68fe3a2712e2a9bbe21eb6dd10)

new makeVolume, makeVolumeReturnID, makeNode, getVolume, getNode,
    signedInsertTest, signedInsertTestReturnID, signedLookupTest, 
    ri(`rho:registry:insertArbitrary`), 
    rl(`rho:registry:lookup`),
    stdout(`rho:io:stdout`),
    stdoutAck(`rho:io:stdoutAck`), ack in { 
        makeVolume!(*makeVolumeReturnID,{ "/f1r3fly" : { ".." : "/f1r3fly" } }) |
        for(@rootNodeId <- makeVolumeReturnID) {
            getVolume!(rootNodeId, ["/f1r3fly"], *ack)
        } |

        contract makeVolume(registryIdentifier, @volumeMap) = {
            stdout!("ONCHAIN_VOLUME_INSERT_TEST: create volume map to store in the registry") |
            new regCB, innerAck in {
                stdoutAck!(volumeMap, *innerAck) |
                for(_ <- innerAck){
                    stdout!("ONCHAIN_VOLUME_INSERT_TEST: adding volume map to the registry and getting back a new identifier") |
                    ri!(volumeMap, *regCB) |
                    for(@uri <- regCB) {
                        stdout!("@uri <- regCB hit") |
                        stdout!("ONCHAIN_VOLUME_INSERT_TEST: got an identifier for volume map from the registry") |
                        stdout!(uri) |
                        registryIdentifier!(uri)
                    }
                }
            }
        } |

      // "/mumble/frotz/fu/bar" -> [ "/mumble" "/frotz" "/fu" "/bar" ]
      contract makeNode(@path, @folder, @handle, @node, result) = {
        match path {
          [] => { folder.set(handle,node) | result!(folder) }
          [head ...tail] => {
            match folder.get(head) {
              Nil => {
                let chldFldr <- { ".." : head } in { // CHECK let syntax!!!
                  folder.set(head,chldFldr) |
                  makeNode!(tail,chldFldr,handle,node,*result)
                }
              }
              fldr => makeNode!(tail,fldr,handle,node,*result)
            }
          }
        }
      }

      contract getNode(@path, @node, result) = {
     	match path {
          [] => result!( node )
          [head ...tail] => {
            match node.get(head) {
              Nil => result!({ "error" : ("No such file or directory: " ++ head) })
              subNode => getNode!(tail,subNode,*result)
            }
          }
        }
      } |

      contract getVolume(@uri, @path, result) = {
        stdout!("uri= " ++ uri) |
        stdout!("ONCHAIN_VOLUME_LOOKUP_TEST: looking up volume map in the registry using identifier") |
        new lookupResponse, getNodeCB in {
          rl!(uri, *lookupResponse) |
          for(@volume <- lookupResponse) {
            stdout!("ONCHAIN_VOLUME_LOOKUP_TEST: got volume map from the registry using identifier") |
            getNode!(path,volume,getNodeCB) |
            for(@node <- getNodeCB) {
              stdoutAck!(node, *result)
            }
          }
        }
      }
    }

